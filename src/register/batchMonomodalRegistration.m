function [REG, IDs] = batchMonomodalRegistration(imStack, refID, varargin)
% BATCHMONOMODALREGISTRATION
%
% Syntax:
%   [REG, IDs] = batchMonomodalRegistration(imStack, refID, plotFlag)
%
% Input:
%   imStack                 stack of images to register
%   refID                   index of reference image in stack
% Optional key/value inputs:
%   Plot                    whether or not to plot
%   OmitSkips               whether to omit skipped registrations
%   IDs                     epochIDs corresponding to each image
%
% See also:
%   runMonomodalRegistration, MonomodalRegistrationResult, ssim, imwarp
%
% History:
%   ??? - SSP
%   12May2024 - SSP - added RegistrationResult support, cleaned code
%   14May2024 - SSP - fixed backup run parameters and added plotting
% --------------------------------------------------------------------------

    ip = inputParser();
    ip.KeepUnmatched = true;
    ip.CaseSensitive = false;
    ip.PartialMatching = false;
    addOptional(ip, 'TransformType', 'similarity',...
        @(x) ismember(x, {'similarity', 'affine', 'rigid', 'translation'}));
    addParameter(ip, 'OmitSkips', false, @islogical);
    addParameter(ip, 'IDs', 1:size(imStack,3), @isnumeric);
    parse(ip, varargin{:});

    transformType = ip.Results.TransformType;
    omitSkips = ip.Results.OmitSkips;
    IDs = ip.Results.IDs;

    assert(numel(IDs) == size(imStack, 3), 'Number of IDs must match number of images');

    % Extract reference from IDs and imStack
    refIdx = find(IDs == refID); disp(refIdx)
    IDs(refIdx) = [];
    FIXED = imStack(:,:, refIdx);
    regStack = imStack; regStack(:,:,refIdx) = [];

    REG = []; badReg = []; skipReg = [];
    for i = 1:(size(regStack, 3))
        fprintf('Registering %u  ', IDs(i));
        MOVING = squeeze(regStack(:,:,i));
        [S, Q] = runMonomodalRegistration(MOVING, FIXED, transformType, ip.Unmatched);
        if Q.Warning
            fprintf('\t');
            [S, Q] = registerImages(MOVING, FIXED, transformType);
            if Q.Warning
                fprintf('\t');
                [S1, Q1] = runMonomodalRegistration(MOVING, FIXED,...
                    transformType, 'Normalize', false, 'Blur', true);
                [S2, Q2] = runMonomodalRegistration(MOVING, FIXED,...
                    transformType, 'AlignType', "center of mass");
                if Q2.NewSSIM > Q1.NewSSIM
                    S = S2; Q = Q2;
                else
                    S = S1; Q = Q1;
                end
                if Q.Warning
                    assignin('base', sprintf('imBad_%u', i), MOVING);
                    assignin('base', sprintf('imRef_%u', i), FIXED);
                end
            end
        end

        obj = MonomodalRegistrationResult(S, IDs(i), ip.Unmatched);
        obj.setSSIMs(Q.NewSSIM, Q.OldSSIM);
        if Q.NewSSIM < Q.OldSSIM
            badReg = cat(1, badReg, i);
            % Sometimes registration errors occur when the non-registered
            % images are already very similar. Flag these for registration
            % to be skipped.
            if Q.OldSSIM > 0.9
                skipReg = cat(1, skipReg, i);
                obj = MonomodalRegistrationResult(affine2d(eye(3)), IDs(i), ip.Unmatched);
                obj.setSpatialRefObj(FIXED);
                obj.setSSIMs(Q.OldSSIM, Q.OldSSIM);
            end
        end

        REG = cat(1, REG, obj);
    end

    if ~isempty(badReg)
        fprintf('Bad registration for: '); disp(IDs(badReg));
    end
    if omitSkips && ~isempty(skipReg)
        fprintf('Skipping registration for: '); disp(IDs(skipReg));
        REG(skipReg) = []; IDs(skipReg) = [];
    end

    % Summary plot
    figure(); hold on;
    plot(IDs, REG.getOldSSIM(), 'Color', 'k', 'Marker', '.', 'MarkerSize', 14);
    plot(IDs, REG.getSSIM(), 'Color', 'b', 'Marker', '.', 'MarkerSize', 14);
    xlabel('Epoch IDs'); ylabel(sprintf('SSIM to Reference (%u)', refID));
    grid on; ylim([0.75, 1]); set(gca, 'YMinorGrid', 'on');
    title(sprintf('Monomodal Registration (%s)', transformType));
end


function [MOVINGREG, Q] = registerImages(MOVING,FIXED, transformType)
    %registerImages  Register grayscale images using auto-generated code from Registration Estimator app.
    %  [MOVINGREG] = registerImages(MOVING,FIXED) Register grayscale images
    %  MOVING and FIXED using auto-generated code from the Registration
    %  Estimator app. The values for all registration parameters were set
    %  interactively in the app and result in the registered image stored in the
    %  structure array MOVINGREG.

    % Auto-generated by registrationEstimator app on 14-May-2024
    % SSP - Added transform type input
    %-----------------------------------------------------------

    % Default spatial referencing objects
    fixedRefObj = imref2d(size(FIXED));
    movingRefObj = imref2d(size(MOVING));

    % Intensity-based registration
    [optimizer, metric] = imregconfig('monomodal');
    optimizer.GradientMagnitudeTolerance = 1.00000e-04;
    optimizer.MinimumStepLength = 1.00000e-05;
    optimizer.MaximumStepLength = 3.15000e-02;
    optimizer.MaximumIterations = 100;
    optimizer.RelaxationFactor = 0.500000;

    % Align centers
    fixedCenterXWorld = mean(fixedRefObj.XWorldLimits);
    fixedCenterYWorld = mean(fixedRefObj.YWorldLimits);
    movingCenterXWorld = mean(movingRefObj.XWorldLimits);
    movingCenterYWorld = mean(movingRefObj.YWorldLimits);
    translationX = fixedCenterXWorld - movingCenterXWorld;
    translationY = fixedCenterYWorld - movingCenterYWorld;

    % Coarse alignment
    initTform = affinetform2d();
    initTform.A(1:2,3) = [translationX ; translationY];

    % Apply transformation
    tform = imregtform(MOVING, movingRefObj, FIXED, fixedRefObj, ...
        transformType, optimizer, metric, ...
        'PyramidLevels', 3, 'InitialTransformation', initTform);
    MOVINGREG.Transformation = tform;
    MOVINGREG.RegisteredImage = imwarp(MOVING, movingRefObj, tform, ...
        'OutputView', fixedRefObj, 'SmoothEdges', true);

    % Store spatial referencing object
    MOVINGREG.SpatialRefObj = fixedRefObj;

    newSSIM = ssim(FIXED, MOVINGREG.RegisteredImage);
    oldSSIM = ssim(FIXED, MOVING);
    Q = struct('Warning', newSSIM<oldSSIM, ...
        'OldSSIM', oldSSIM, 'NewSSIM', newSSIM);
    if Q.Warning
        cprintf('UnterminatedStrings', 'WARNING!!! '); % Registration failed
    end

    fprintf('SSIM = %.3f --> %.3f\n', oldSSIM, newSSIM);
end

